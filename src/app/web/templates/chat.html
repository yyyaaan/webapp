{% extends 'base.html' %}

{% block title %}Chat - Yan{% endblock %}

{% block content %}

<div class="row">
  <div class="col-12 col-lg-8 mx-auto">
    <div class="card">
      <div class="card-body d-flex flex-column" style="height:80vh">
        <div id="chat-messages" class="flex-grow-1 overflow-auto mb-3">
          <!-- message bubbles will be appended here -->
        </div>

        <form id="chat-form" class="input-group">
          <textarea id="chat-input" name="message" class="form-control" placeholder="Type a message..." rows="2"></textarea>
          <button id="chat-send" class="btn btn-primary" type="submit">Send</button>
        </form>
      </div>
    </div>
  </div>

    <div class="col-12 col-lg-8 mx-auto mt-5">
        <p class=" text-end text-muted small">chat mode: {{ agent }}</p>
    </div>
</div>




<style>
  .bubble { max-width: 80%; padding: .6rem 1rem; border-radius: 16px; margin-bottom: .5rem; display: inline-block; }
  .bubble.user { background: #e9f5ff; align-self: flex-end; }
  .bubble.assistant { background: #f1f1f1; align-self: flex-start; }
  #chat-messages { display:flex; flex-direction:column; gap:6px; }
</style>

<script>
// Client-side chat history: array of {role, content} for tracking conversation
let chatHistory = [];

document.getElementById('chat-form').addEventListener('submit', async function (e) {
  e.preventDefault();
  const input = document.getElementById('chat-input');
  const msg = input.value.trim();
  if (!msg) return;

  // Render user bubble
  const messages = document.getElementById('chat-messages');
  const userBubble = document.createElement('div');
  userBubble.className = 'bubble user ms-auto';
  userBubble.textContent = msg;
  messages.appendChild(userBubble);
  messages.scrollTop = messages.scrollHeight;

  input.value = '';
  input.disabled = true;
  document.getElementById('chat-send').disabled = true;

  // Add user message to chat history
  chatHistory.push({role: 'user', content: msg});

  // Prepare form data with chat history
  const formData = new FormData();
  formData.append('message', msg);
  formData.append('chat_history', JSON.stringify(chatHistory));

  // Remove feedback buttons from previous assistant bubble (only latest gets them)
  const prevFeedback = document.querySelectorAll('.feedback-toolbar');
  prevFeedback.forEach(n => n.remove());

  // Create assistant bubble that will be filled progressively
  const assistantBubble = document.createElement('div');
  assistantBubble.className = 'bubble assistant';
  assistantBubble.textContent = '';
  // temporary message id used for feedback binding
  const msgId = `msg-${Date.now()}`;
  assistantBubble.dataset.messageId = msgId;
  messages.appendChild(assistantBubble);
  // create feedback toolbar (thumbs up/down) and attach after bubble
  const toolbar = document.createElement('div');
  toolbar.className = 'feedback-toolbar mt-1';
  toolbar.style.display = 'flex';
  toolbar.style.gap = '8px';
  toolbar.style.alignItems = 'center';
  toolbar.innerHTML = `
    <button class="btn btn-outline-secondary btn-sm" aria-label="thumbs up" data-feedback="up"><i class="fas fa-thumbs-up"></i></button>
    <button class="btn btn-outline-secondary btn-sm" aria-label="thumbs down" data-feedback="down"><i class="fas fa-thumbs-down"></i></button>
    <span class="feedback-status small text-muted ms-2"></span>
  `;
  messages.appendChild(toolbar);
  messages.scrollTop = messages.scrollHeight;

  // Store the full response object (JSON) for context
  let fullResponseData = {};

  try {
    const resp = await fetch('/chat/stream', { method: 'POST', body: formData });
    if (!resp.body) throw new Error('No streaming body available');

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const text = decoder.decode(value, { stream: true });
      // Accumulate buffer and parse newline-delimited JSON
      buffer += text;
      const lines = buffer.split('\n');
      // Process all complete lines
      for (let i = 0; i < lines.length - 1; i++) {
        const line = lines[i].trim();
        if (line) {
          try {
            const jsonData = JSON.parse(line);
            // Extract output for display
            if (jsonData.output) {
              assistantBubble.textContent = jsonData.output;
            }
            // Store the full response for later context
            fullResponseData = jsonData;
          } catch (e) {
            console.warn('Failed to parse JSON line:', line, e);
          }
        }
      }
      // Keep incomplete line in buffer
      buffer = lines[lines.length - 1];
      messages.scrollTop = messages.scrollHeight;
    }
    // Parse any remaining buffer content
    if (buffer.trim()) {
      try {
        const jsonData = JSON.parse(buffer);
        if (jsonData.output) {
          assistantBubble.textContent = jsonData.output;
        }
        fullResponseData = jsonData;
      } catch (e) {
        console.warn('Failed to parse final buffer:', buffer);
      }
    }
    // Add assistant response to chat history (stringified full response object)
    chatHistory.push({
      role: 'assistant',
      content: JSON.stringify(fullResponseData)
    });
    // after streaming completes, wire up feedback buttons
    const attachedToolbar = document.querySelector('.feedback-toolbar');
    if (attachedToolbar) {
      attachedToolbar.querySelectorAll('button[data-feedback]').forEach(btn => {
        btn.addEventListener('click', async function () {
          const fb = this.dataset.feedback;
          const statusEl = attachedToolbar.querySelector('.feedback-status');
          try {
            const res = await fetch('/chat/feedback', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ message_id: msgId, feedback: fb })
            });
            if (res.ok) {
              statusEl.textContent = fb === 'up' ? 'Thanks for the thumbs up' : 'Thanks for the feedback';
              if (fb === 'up') this.classList.remove('btn-outline-success'), this.classList.add('btn-success');
              if (fb === 'down') this.classList.remove('btn-outline-danger'), this.classList.add('btn-danger');
            } else {
              statusEl.textContent = 'Feedback failed';
            }
          } catch (err) {
            statusEl.textContent = 'Error';
            console.error(err);
          }
        });
      });
    }
  } catch (err) {
    assistantBubble.textContent += '\n[Error receiving stream]';
    console.error(err);
  } finally {
    input.disabled = false;
    document.getElementById('chat-send').disabled = false;
    input.focus();
  }
});

// Allow multiline entry: Shift+Enter -> newline, Enter -> submit
document.getElementById('chat-input').addEventListener('keydown', function (e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    document.getElementById('chat-form').dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
  }
});
</script>

{% endblock %}
